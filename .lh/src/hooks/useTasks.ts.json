{
    "sourceFile": "src/hooks/useTasks.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1767727258025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767727263642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-cleimport { useCallback, useEffect, useMemo, useState } from 'react';\r\n+import { useCallback, useEffect, useMemo, useState } from 'react';\r\n import { DerivedTask, Metrics, Priority, Status, Task } from '@/types';\r\n import {\r\n   computeAverageROI,\r\n   computePerformanceGrade,\r\n"
                }
            ],
            "date": 1767727258025,
            "name": "Commit-0",
            "content": "cleimport { useCallback, useEffect, useMemo, useState } from 'react';\r\nimport { DerivedTask, Metrics, Priority, Status, Task } from '@/types';\r\nimport {\r\n  computeAverageROI,\r\n  computePerformanceGrade,\r\n  computeRevenuePerHour,\r\n  computeTimeEfficiency,\r\n  computeTotalRevenue,\r\n  withDerived,\r\n  sortTasks as sortDerived,\r\n} from '@/utils/logic';\r\n// Local storage removed per request; keep everything in memory\r\nimport { generateSalesTasks } from '@/utils/seed';\r\n\r\ninterface UseTasksState {\r\n  tasks: Task[];\r\n  loading: boolean;\r\n  error: string | null;\r\n  derivedSorted: DerivedTask[];\r\n  metrics: Metrics;\r\n  lastDeleted: Task | null;\r\n  addTask: (task: Omit<Task, 'id'> & { id?: string }) => void;\r\n  updateTask: (id: string, patch: Partial<Task>) => void;\r\n  deleteTask: (id: string) => void;\r\n  undoDelete: () => void;\r\n}\r\n\r\nconst INITIAL_METRICS: Metrics = {\r\n  totalRevenue: 0,\r\n  totalTimeTaken: 0,\r\n  timeEfficiencyPct: 0,\r\n  revenuePerHour: 0,\r\n  averageROI: 0,\r\n  performanceGrade: 'Needs Improvement',\r\n};\r\n\r\nexport function useTasks(): UseTasksState {\r\n  const [tasks, setTasks] = useState<Task[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [lastDeleted, setLastDeleted] = useState<Task | null>(null);\r\n\r\n  function normalizeTasks(input: any[]): Task[] {\r\n    const now = Date.now();\r\n    const validPriorities: Priority[] = ['High', 'Medium', 'Low'];\r\n    const validStatuses: Status[] = ['Todo', 'In Progress', 'Done'];\r\n    \r\n    return (Array.isArray(input) ? input : [])\r\n      .map((t, idx) => {\r\n        // Validate and generate ID\r\n        const id = t.id && typeof t.id === 'string' && t.id.trim() ? t.id.trim() : crypto.randomUUID();\r\n        \r\n        // Validate title\r\n        const title = t.title && typeof t.title === 'string' ? t.title.trim() : `Untitled Task ${idx + 1}`;\r\n        \r\n        // Validate revenue (must be a valid number, not NaN)\r\n        const revenueNum = Number(t.revenue);\r\n        const revenue = !isNaN(revenueNum) && isFinite(revenueNum) && revenueNum >= 0 ? revenueNum : 0;\r\n        \r\n        // Validate timeTaken (must be > 0)\r\n        const timeTakenNum = Number(t.timeTaken);\r\n        const timeTaken = !isNaN(timeTakenNum) && isFinite(timeTakenNum) && timeTakenNum > 0 ? timeTakenNum : 1;\r\n        \r\n        // Validate priority\r\n        const priority = validPriorities.includes(t.priority) ? t.priority : 'Medium';\r\n        \r\n        // Validate status\r\n        const status = validStatuses.includes(t.status) ? t.status : 'Todo';\r\n        \r\n        const created = t.createdAt ? new Date(t.createdAt) : new Date(now - (idx + 1) * 24 * 3600 * 1000);\r\n        const completed = t.completedAt || (status === 'Done' ? new Date(created.getTime() + 24 * 3600 * 1000).toISOString() : undefined);\r\n        \r\n        return {\r\n          id,\r\n          title,\r\n          revenue,\r\n          timeTaken,\r\n          priority,\r\n          status,\r\n          notes: t.notes && typeof t.notes === 'string' ? t.notes.trim() : undefined,\r\n          createdAt: created.toISOString(),\r\n          completedAt: completed,\r\n        } as Task;\r\n      })\r\n      .filter((task, index, self) => {\r\n        // Remove duplicates by ID (keep first occurrence)\r\n        return self.findIndex(t => t.id === task.id) === index;\r\n      });\r\n  }\r\n\r\n  // Initial load: public JSON -> fallback generated dummy\r\n  useEffect(() => {\r\n    let isMounted = true;\r\n    async function load() {\r\n      try {\r\n        console.log('[useTasks] Fetching initial tasks from /tasks.json');\r\n        const res = await fetch('/tasks.json');\r\n        if (!res.ok) throw new Error(`Failed to load tasks.json (${res.status})`);\r\n        const data = (await res.json()) as any[];\r\n        const normalized: Task[] = normalizeTasks(data);\r\n        const finalData = normalized.length > 0 ? normalized : generateSalesTasks(50);\r\n        if (isMounted) setTasks(finalData);\r\n      } catch (e: any) {\r\n        if (isMounted) setError(e?.message ?? 'Failed to load tasks');\r\n      } finally {\r\n        if (isMounted) {\r\n          setLoading(false);\r\n        }\r\n      }\r\n    }\r\n    load();\r\n    return () => {\r\n      isMounted = false;\r\n    };\r\n  }, []);\r\n\r\n  const derivedSorted = useMemo<DerivedTask[]>(() => {\r\n    const withRoi = tasks.map(withDerived);\r\n    return sortDerived(withRoi);\r\n  }, [tasks]);\r\n\r\n  const metrics = useMemo<Metrics>(() => {\r\n    if (tasks.length === 0) return INITIAL_METRICS;\r\n    const totalRevenue = computeTotalRevenue(tasks);\r\n    const totalTimeTaken = tasks.reduce((s, t) => s + t.timeTaken, 0);\r\n    const timeEfficiencyPct = computeTimeEfficiency(tasks);\r\n    const revenuePerHour = computeRevenuePerHour(tasks);\r\n    const averageROI = computeAverageROI(tasks);\r\n    const performanceGrade = computePerformanceGrade(averageROI);\r\n    return { totalRevenue, totalTimeTaken, timeEfficiencyPct, revenuePerHour, averageROI, performanceGrade };\r\n  }, [tasks]);\r\n\r\n  const addTask = useCallback((task: Omit<Task, 'id'> & { id?: string }) => {\r\n    setTasks(prev => {\r\n      const id = task.id ?? crypto.randomUUID();\r\n      const timeTaken = task.timeTaken <= 0 ? 1 : task.timeTaken; // auto-correct\r\n      const createdAt = new Date().toISOString();\r\n      const status = task.status;\r\n      const completedAt = status === 'Done' ? createdAt : undefined;\r\n      return [...prev, { ...task, id, timeTaken, createdAt, completedAt }];\r\n    });\r\n  }, []);\r\n\r\n  const updateTask = useCallback((id: string, patch: Partial<Task>) => {\r\n    setTasks(prev => {\r\n      const next = prev.map(t => {\r\n        if (t.id !== id) return t;\r\n        const merged = { ...t, ...patch } as Task;\r\n        if (t.status !== 'Done' && merged.status === 'Done' && !merged.completedAt) {\r\n          merged.completedAt = new Date().toISOString();\r\n        }\r\n        return merged;\r\n      });\r\n      // Ensure timeTaken remains > 0\r\n      return next.map(t => (t.id === id && (patch.timeTaken ?? t.timeTaken) <= 0 ? { ...t, timeTaken: 1 } : t));\r\n    });\r\n  }, []);\r\n\r\n  const deleteTask = useCallback((id: string) => {\r\n    setTasks(prev => {\r\n      const target = prev.find(t => t.id === id) || null;\r\n      setLastDeleted(target);\r\n      return prev.filter(t => t.id !== id);\r\n    });\r\n  }, []);\r\n\r\n  const undoDelete = useCallback(() => {\r\n    if (!lastDeleted) return;\r\n    setTasks(prev => [...prev, lastDeleted]);\r\n    setLastDeleted(null);\r\n  }, [lastDeleted]);\r\n\r\n  return { tasks, loading, error, derivedSorted, metrics, lastDeleted, addTask, updateTask, deleteTask, undoDelete };\r\n}\r\n\r\n\r\n"
        }
    ]
}